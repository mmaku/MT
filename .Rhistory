seq_len(0)
seq_len(2)
NCOL()
ncol()
ncol(1)
NCOL(1)
1+c(2,3)
c(2,3)+1
cbind(1:5,2:6)
adj <- cbind(1:5,2:6,3:7)
for (i in seq_len(NCOL(adj)-1)+1)
{
for (j in seq_len(i-1))
{
adj[j,i]
}
for (i in seq_len(NCOL(adj)-1)+1)
{
for (j in seq_len(i-1))
{
print(adj[j,i])
}
adj
NCOL(adj)
seq_len(NCOL(adj)-1)+1
for (i in seq_len(NCOL(adj)-1)+1)
{
for (j in seq_len(i-1))
{
print(adj[j,i])
}
adj <- cbind(1:5,2:6,3:7,4:8,5:9)
adj
for (i in seq_len(NCOL(adj)-1)+1)
{
for (j in seq_len(i-1))
{
print(adj[j,i])
}
adj
for (i in seq_len(NCOL(adj)-1)+1)
{
for (j in seq_len(i-1))
{
print(adj[j,i])
}
adj
for (i in seq_len(NCOL(adj)-1)+1)
{
for (j in seq_len(i-1))
{
print(paste(adj[j,i], "o", j, "o", i)
}
for (i in seq_len(NCOL(adj)-1)+1)
{
for (j in seq_len(i-1))
{
print(paste(adj[j,i], "o", j, "o", i))
}
adj
b
as_adj(b)
max_cliques(b)
plot(b)
max_cliques(b)
n = 150,
p = 200,
graphType = "cluster",
alpha = 0.1,
penalizeDiagonal = FALSE,
additionalMethods = NULL,
iterations = 250,  # Numer of graphs simulated to calculated FDR
epsilon = 10e-4,
verbose = TRUE
n = 150
p = 200
graphType = "cluster"
alpha = 0.1
penalizeDiagonal = FALSE
additionalMethods = NULL
iterations = 250  # Numer of graphs simulated to calculated FDR
epsilon = 10e-4
verbose = TRUE
if(verbose)
{
cat("Starting FDR, Sensitivity & Specificity simulations\nn = ",
n, "\np = ", p, "\ngraph structure = ", graphType,
"\nsimulations number = ", iterations)
progressBar <- txtProgressBar(min = 0, max = iterations, style = 3)
setTxtProgressBar(progressBar, 0)
}
if(verbose)
close(progressBar)
methods <- c("gLASSO",
"holmgSLOPE",
"BHgSLOPE", names(additionalMethods))
zeros <- rep_len(0, length(methods))
results <- data.frame(procedure = methods, FDR = zeros, SN = zeros, SP = zeros)
results
iterations = 2
# gLASSO parameters
banerjeeLambda <- lambdaSelector(input = p, n = n, alpha = alpha, method = "banerjee", verbose = FALSE)
# gSLOPE parameters
holmlambda <- lambdaSelector(input = p, n = n, alpha = alpha, method = "holm", verbose = FALSE)
source("01 auxilaryFunctions.R")
source("07 admmGSLOPE.R")
source("10 simpleMeasures.R")
# gLASSO parameters
banerjeeLambda <- lambdaSelector(input = p, n = n, alpha = alpha, method = "banerjee", verbose = FALSE)
# gSLOPE parameters
holmlambda <- lambdaSelector(input = p, n = n, alpha = alpha, method = "holm", verbose = FALSE)
BHlambda <- lambdaSelector(input = p, n = n, alpha = alpha, method = "BH", verbose = FALSE)
banerjeeLambda
holmlambda
BHlambda
plot(BHlambda)
plot(holmlambda)
generatedData <- huge.generator(n = n, d = p, graph = graphType, verbose = FALSE)
require(glasso, quietly = TRUE)  # graphical lasso
require(huge, quietly = TRUE)    # graphical models
require(R.utils, quietly = TRUE) # doCall
generatedData <- huge.generator(n = n, d = p, graph = graphType, verbose = FALSE)
adjacent <- properAdjacent(generatedData$theta)
generatedData$theta
typeof(generatedData$theta)
properAdjacent <- function(input)
{
# if(!is.matrix(input)) stop(("The input is not a matrix"))
output <- as.matrix(input != 0)
if(sum(diag(output)) == 0)
diag(output) <- TRUE
return(output)
}
adjacent <- properAdjacent(generatedData$theta)
adjacent
omegaHat <- gslopeADMM(sampleCovariance = generatedData$sigmahat, lambda = BHlambda,
penalizeDiagonal = penalizeDiagonal,
truncate = TRUE, absoluteEpsilon = epsilon,
verbose = FALSE)$precisionMatrix
omegaHat
FDP(omegaHat, adjacent)
SN(omegaHat, adjacent)
SP(omegaHat, adjacent)
plotMatrix(omegaHat)
plotMatrix(adjacent)
plotDiffrence(omegaHat, adjacent)
adjacentMatrix <- adjacent
adjacentMatrixIG <- igraph::graph_from_adjacency_matrix(adjacentMatrix)
adjacentMatrixIG
adjacentMatrix
estimatedMatrix <- omegaHat
adjacentMatrix[j,i] <- igraph::edge_connectivity(adjacentMatrixIG, j, i)
{
adjacentMatrix[j,i] <- igraph::edge_connectivity(adjacentMatrixIG, j, i)
}
estimatedMatrix
upper(adjacent)
upper(adjacent)[1:10]
upper(adjacent)[1:10,1:10]
upper(adjacent)[1:10]
adjacent[1:10]
adjacent[1:10,1:10]
upper(adjacent)[1:10]
adjacent[1:10,1:10]
adjacent
upper(adjacent)[1:10]
adjacent[1:10,1:10]
adjacentMatrixIG[1:10,1:10]
NCOL(estimatedMatrix)
seq_len(NCOL(estimatedMatrix)-1)+1
i = 2
j = 2
j = 1
i = 4
igraph::edge_connectivity(adjacentMatrixIG, j, i)
igraph::edge_connectivity(adjacentMatrixIG, j, 5)
igraph::edge_connectivity(adjacentMatrixIG, j, 6)
igraph::edge_connectivity(adjacentMatrixIG, j, 7)
igraph::edge_connectivity(adjacentMatrixIG, j, 8)
igraph::edge_connectivity(adjacentMatrixIG, j, 9)
adjacentMatrixIG[1:10,1:10]
igraph::edge_connectivity(adjacentMatrixIG, 1, 3)
igraph::edge_connectivity(adjacentMatrixIG, 1, 1)
igraph::edge_connectivity(adjacentMatrixIG, 1, 4)
igraph::edge_connectivity(adjacentMatrixIG, 4, 1)
igraph::edge_connectivity(adjacentMatrixIG, 11, 1)
igraph::edge_connectivity(adjacentMatrixIG, 25, 1)
is.zero(adjacentMatrixIG[1:10,1:10])
isZero(adjacentMatrixIG[1:10,1:10])
isZero.default(adjacentMatrixIG[1:10,1:10])
isZero.default(adjacentMatrix[1:10,1:10])
isZero.default(adjacent[1:10,1:10])
isZero(adjacent[1:10,1:10])
is.Zero(adjacent[1:10,1:10])
is.zero(adjacent[1:10,1:10])
# Local FDP
localFDP <- function(estimatedMatrix,
adjacentMatrix)
{
adjacentMatrixIG <- igraph::graph_from_adjacency_matrix(adjacentMatrix)
for (i in seq_len(NCOL(estimatedMatrix)-1)+1)
{
for (j in seq_len(i-1))
{
adjacentMatrix[j,i] <- !isZero(igraph::edge_connectivity(adjacentMatrixIG, j, i))
}
estimatedMatrix <- upper(estimatedMatrix)
adjacentMatrix <- upper(adjacentMatrix)
predictedPositive <- max(c(sum(estimatedMatrix != 0), 1))
return(FP(estimatedMatrix, adjacentMatrix)/predictedPositive)
}
FDP(omegaHat, adjacent)
localFDP(omegaHat, adjacent)
FP(omegaHat, adjacent)
max(c(sum(omegaHat != 0), 1))
max(c(sum(upper(omegaHat) != 0), 1))
FP(omegaHat, adjacent)/max(c(sum(upper(omegaHat) != 0), 1))
adjacentMatrixIG
adjacentMatrixIG <- igraph::graph_from_adjacency_matrix(adjacentMatrix)
for (i in seq_len(NCOL(estimatedMatrix)-1)+1)
{
for (j in seq_len(i-1))
{
adjacentMatrix[j,i] <- !isZero(igraph::edge_connectivity(adjacentMatrixIG, j, i))
}
adjacentMatrix
plotMatrix(adjacentMatrix)
plotMatrix(1*adjacentMatrix)
upper(adjacentMatrix)
plot(adjacentMatrix)
estimatedMatrix <- upper(estimatedMatrix)
adjacentMatrix <- upper(adjacentMatrix)
estimatedMatrix
adjacentMatrix
estimatedMatrix
max(c(sum(estimatedMatrix != 0), 1))
FP(estimatedMatrix, adjacentMatrix)
estimatedMatrix <- upper(estimatedMatrix)
estimatedMatrix
source('C:/Users/Michal/Dropbox/01 Studia/04 Praca magisterska/gSLOPEtesting/errorTypes.R', echo=TRUE)
FP(estimatedMatrix, adjacentMatrix)
generatedData <- huge.generator(n = n, d = p, graph = graphType, verbose = FALSE)
adjacent <- properAdjacent(generatedData$theta)
omegaHat <- gslopeADMM(sampleCovariance = generatedData$sigmahat, lambda = BHlambda,
penalizeDiagonal = penalizeDiagonal,
truncate = TRUE, absoluteEpsilon = epsilon,
verbose = FALSE)$precisionMatrix
omegaHat
adjacent
FDP(omegaHat, adjacent)
SN(omegaHat, adjacent)
SP(omegaHat, adjacent)
localFDP(omegaHat, adjacent)
require(reshape2, quietly = TRUE) # melt
# Melts matrix into 3-column DF
meltingMatrix <- function(matrix,
index = NULL)
{
colnames(matrix) <- 1:ncol(matrix)
rownames(matrix) <- 1:ncol(matrix)
matrix <- reshape2::melt(matrix)
if(!is.null(index))
matrix <- cbind(matrix, index)
return(matrix)
}
# Simple upper triangle function
upper <- function(input)
{
return(input[upper.tri(input, diag = FALSE)])
}
# Melts matrix into 3-column DF
meltingMatrix <- function(matrix,
index = NULL)
{
colnames(matrix) <- seq_along(NCOL(matrix))
rownames(matrix) <- seq_along(NROW(matrix))
matrix <- reshape2::melt(matrix)
if(!is.null(index))
matrix <- cbind(matrix, index)
return(matrix)
}
meltingMatrix(matrix = rnorm(400))
meltingMatrix(matrix = rnorm(400), 20, 02)
meltingMatrix(matrix = rnorm(400), 20, 20)
meltingMatrix(matrix(rnorm(400), 20, 20))
meltingMatrix(matrix(rnorm(400)))
rnorm(100)
meltingMatrix(matrix(rnorm(100, 1,)))
meltingMatrix(matrix(rnorm(100, 10)))
meltingMatrix(matrix(rnorm(100, 10, 10)))
meltingMatrix(matrix(rnorm(100), 10, 10))
meltingMatrix(matrix(rnorm(100), c(10, 10)))
matrix(rnorm(100), 10, 10)
meltingMatrix(matrix(rnorm(100), 10, 10))
meltingMatrix(matrix(rnorm(100), 10, 10)))
matrix(rnorm(100), 10, 10)
matrix<-matrix(rnorm(100), 10, 10)
colnames(matrix) <- seq_along(NCOL(matrix))
NCOL(matrix)
seq_along(NCOL(matrix))
seq_len(NCOL(matrix))
colnames(matrix) <- seq_len(NCOL(matrix))
rownames(matrix) <- seq_len(NROW(matrix))
rownames
matrix <- reshape2::melt(matrix)
matrix
is.null(index)
index = NULL
matrix <- cbind(matrix, "cv")
matrix
1:*TRUE
1*TRUE
TRUE*1
as.numeric(TRUE)
hubData <- scale(huge.generator(n=400, d=100, graph="hub")$data) # Generate data with hub structures
source("lambdas.R")
source("auxilaryFunctions.R")
source("admmGLASSO.R")
lambdaBanerjee(hubData)
hubData <- scale(huge.generator(n=400, d=100, graph="hub")$data) # Generate data with hub structures
require(huge)
require(tictoc)
require(glasso)
hubData <- scale(huge.generator(n=400, d=100, graph="hub")$data) # Generate data with hub structures
lambdaBanerjee(hubData)
hubData
lambdaSelector(hubData)
lambdaSelector(hubData, method = "banerjee")
seq(from = .4, to = 1.5, length.out = 25)
hubLambda <- lambdaSelector(hubData, method = "banerjee")
tic("Hub")
for(mu in seq(from = .5, to = 1.5, length.out = 25))
{
tic(mu)
X <- glassoADMM(cov(hubData), mu = mu, lambda = hubLambda, penalizeDiagonal =  F)
toc()
}
toc()
tic("Hub")
for(mu in seq(from = .5, to = 1.5, length.out = 25))
{
tic(mu)
X <- glassoADMM(cov(hubData), mu = mu, lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)
toc()
}
toc()
tic("Hub")
for(mu in muSeries)
{
tic(ADMM)
X <- glassoADMM(cov(hubData), mu = mu, lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)
toc()
tic(graphicalLasso)
X <- glasso(cov(hubData), rho = mu, lambda = hubLambda, penalize.diagonal =  FALSE)
toc()
}
toc()
require(glasso)
require(huge)
require(tictoc)
source("lambdas.R")
source("auxilaryFunctions.R")
source("admmGLASSO.R")
set.seed(100)
hubData <- scale(huge.generator(n=400, d=100, graph="hub")$data) # Generate data with hub structures
clusterData <- scale(huge.generator(n=200, d=200, graph="cluster")$data) # Generate data with hub structures
hubLambda <- lambdaSelector(hubData, method = "banerjee")
muSeries <- seq(from = .5, to = 1.5, length.out = 25)
results <- matrix(0, nrow = length(muSeries))
tic("Hub")
for(mu in muSeries)
{
tic(ADMM)
X <- glassoADMM(cov(hubData), mu = mu, lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)
toc()
tic(graphicalLasso)
X <- glasso(cov(hubData), rho = mu, lambda = hubLambda, penalize.diagonal =  FALSE)
toc()
}
toc()
tic("Hub")
for(mu in muSeries)
{
tic("ADMM")
X <- glassoADMM(cov(hubData), mu = mu, lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)
toc()
tic("graphicalLasso")
X <- glasso(cov(hubData), rho = mu, lambda = hubLambda, penalize.diagonal =  FALSE)
toc()
}
toc()
for(mu in muSeries)
{
tic("ADMM")
X <- glassoADMM(cov(hubData), mu = mu, lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)
toc()
}
tic("graphicalLasso")
X <- glasso(cov(hubData), rho = hubLambda, penalize.diagonal =  FALSE)
toc()
for(mu in muSeries)
{
tic("ADMM")
X <- glassoADMM(cov(hubData), mu = mu, lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)
toc()
}
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("graphicalLasso")
X <- glasso(cov(hubData), rho = hubLambda, penalize.diagonal =  FALSE)$
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("graphicalLasso")
X <- glasso(cov(hubData), rho = hubLambda, penalize.diagonal =  FALSE)$wi
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("graphicalLasso")
X <- glasso(cov(hubData), rho = hubLambda, penalize.diagonal =  FALSE)$wi
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("graphicalLasso")
X <- glasso(cov(hubData), rho = hubLambda, penalize.diagonal =  FALSE)$wi
toc()
tic("ADMM")
X <- glassoADMM(cov(hubData), lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("graphicalLasso")
X <- glasso(cov(hubData), rho = hubLambda, penalize.diagonal =  FALSE)$wi
toc()
hubData <- scale(huge.generator(n=400, d=100, graph="hub")$data) # Generate data with hub structures
hubLambda <- lambdaSelector(hubData, method = "banerjee")
hubLambda
hubLambda <- lambdaSelector(cov(hubData), method = "banerjee")
hubLambda <- lambdaSelector(cov(hubData), n=400, method = "banerjee")
hubLambda
log(det(cov(hubData)))
covCluster <- cov(clusterData)
covHub <- cov(hubData)
X*covHub
X%*%covHub
norm(X)
norm(X, "O")
norm(X, "I")
norm(X, "F")
abs(X)
sum(abs(X))
norm(X, "F")
norm(X, "F")^2
norm(X, "O")
X
abs(X)
- log(det(X)) + tr(X%*%covHub) + hubLambda*norm(X, "1")
- log(det(X)) + sum(diag(X%*%covHub)) + hubLambda*sum(abs(X))
- log(det(X)) + sum(diag(X%*%covHub)) + hubLambda*norm(X, "1")
tic("ADMM")
precADMM <- glassoADMM(covHub, lambda = hubLambda, penalizeDiagonal =  FALSE, verbose = FALSE)$precisionMatrix
toc()
tic("graphicalLasso")
precGL <- glasso(covHub, rho = hubLambda, penalize.diagonal =  FALSE)$wi
toc()
- log(det(precADMM)) + sum(diag(precADMM%*%covHub)) + hubLambda*sum(abs(precADMM))
- log(det(precADMM)) + sum(diag(precADMM%*%covHub)) + hubLambda*norm(precADMM, "1")
-log(det(precADMM)) + sum(diag(precADMM%*%covHub)) + hubLambda*sum(abs(precADMM))
-log(det(precADMM)) + sum(diag(precADMM%*%covHub)) + hubLambda*norm(precADMM, "1")
-log(det(precGL)) + sum(diag(precGL%*%covHub)) + hubLambda*sum(abs(precGL))
-log(det(precGL)) + sum(diag(precGL%*%covHub)) + hubLambda*norm(precGL, "1")
-log(det(precADMM)) + sum(diag(precADMM%*%covHub)) + hubLambda*sum(abs(precADMM))
-log(det(precADMM)) + sum(diag(precADMM%*%covHub)) + hubLambda*norm(precADMM, "1")
-log(det(precGL)) + sum(diag(precGL%*%covHub)) + hubLambda*sum(abs(precGL))
-log(det(precGL)) + sum(diag(precGL%*%covHub)) + hubLambda*norm(precGL, "1")
glassoADMM
require(microbenmark)
install.packages("microbenmark")
devtools::install_github("olafmersmann/microbenchmarkCore")
devtools::install_github("olafmersmann/microbenchmark")
devtools::install_github("olafmersmann/microbenchmarkCore")
.libPaths()
file.path(R.home("bin"), "R")
normalizePath(file.path(R.home("bin"), "R"))
normalizePath(R.home("bin"))
Sys.getenv("R_HOME")
shortPathName(R.home("bin"))
devtools::install_github("olafmersmann/microbenchmarkCore")
system(full)
system("C:/PROGRA~1/R/R-35~1.0/bin/x64/R")
system('"C:/PROGRA~1/R/R-35~1.0/bin/x64/R" --no-site-file --no-environ --no-save --no-restore --quiet CMD config CC')
devtools::install_github("olafmersmann/microbenchmarkCore")
