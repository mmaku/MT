{
if(verbose)
{
cat("Starting ADMM gLASSO procedure...")
progressBar <- txtProgressBar(min = 0, max = 1/absoluteEpsilon, style = 3)
setTxtProgressBar(progressBar, 0)
}
# Checks
if(!is.matrix(lambda) & length(lambda)!=1 & length(lambda)!=nrow(sampleCovariance))
{
stop("Wrong number of elements in lambda")
}
if(length(lambda)==1)
{
if(lambda==0)
{
warning("With lambda=0, there may be convergence problems if the input matrix is not of full rank")
}
lambda <- round(lambda, round(log10( (1/absoluteEpsilon))))
Z <- sampleCovariance*0 # Initialize Lagragian to be nothing (seems to work well)
Y <- Z
X <- diag(nrow = nrow(sampleCovariance), ncol = ncol(sampleCovariance))
for(n in 1:maxIter)
{
# Solve sub-problem to solve X
Ctilde <- Y-Z-sampleCovariance/mu
Ceigen <- eigen(Ctilde)
CeigenVal <- Ceigen$val
CeigenVec <- Ceigen$vec
Fmu <- 1/2*diag(CeigenVal+sqrt(CeigenVal*CeigenVal+4/mu))
X <- CeigenVec%*%Fmu%*%t(CeigenVec)
# Solve sub-problem to solve Y
Yold <- Y
Y <- softThresholding(X+Z, lambda/mu, penalizeDiagonal)
# Update the Lagrangian
Z <- Z + mu*(X-Y)
# Residuals
primalResidual <- norm(X-Y, type = "F")
dualResidual   <- norm(mu*(Y-Yold), type = "F")
# Stopping criteria
primalEpsilon <- absoluteEpsilon # + relativeEpsilon*max(l2norm(X), l2norm(Y))
dualEpsilon   <- absoluteEpsilon # + relativeEpsilon*l2norm(Z)
if(verbose)
setTxtProgressBar(progressBar, min(1/primalResidual, 1/dualResidual))
if(primalResidual < primalEpsilon & dualResidual < dualEpsilon)
break
# if(n %% 10000 == 0)
#     print(paste(n, "iterations done..."), quote = F)
}
if(truncate)
X[X < absoluteEpsilon] <- 0
if(verbose)
close(progressBar)
return(list(sampleCovariance = sampleCovariance,
lambda = lambda,
lagrangianParameter = mu,
diagonalPenalization = penalizeDiagonal,
precisionMatrix = X,
covarianceMatrix = solve(X),
residuals = c(primalResidual, dualResidual),
iterations = n,
truncated = truncate,
epsilon = absoluteEpsilon))
}
data  <- scale(dataSimulator(n = 100, SNR = 1, K = 5, numb.vars = 30, max.dim = 3)$X)
source("01 auxilaryFunctions.R")
source("07 admmGSLOPE.R")
data  <- scale(dataSimulator(n = 100, SNR = 1, K = 5, numb.vars = 30, max.dim = 3)$X)
sampleCovariance <- cov(data)
n     <- nrow(data)
p     <- ncol(data)
m     <- p*(p-1)/2
alpha <- 0.05
m_banerjee <- p^2
lambda <- qt(1-alpha/2/m_banerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/m_banerjee, df = n-2)^2)
k = 1:m
lambdaBis <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
lambdaSeries <- c(rep(lambdaBis[1], p), rep(lambdaBis, each=2))
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = T, truncate = T)$precisionMatrix
set.seed(100)
data  <- scale(dataSimulator(n = 100, SNR = 1, K = 5, numb.vars = 30, max.dim = 3)$X)
sampleCovariance <- cov(data)
n     <- nrow(data)
p     <- ncol(data)
m     <- p*(p-1)/2
alpha <- 0.05
m_banerjee <- p^2
lambda <- qt(1-alpha/2/m_banerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/m_banerjee, df = n-2)^2)
k = 1:m
lambdaBis <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
lambdaSeries <- c(rep(lambdaBis[1], p), rep(lambdaBis, each=2))
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = T, truncate = T)$precisionMatrix
source("01 auxilaryFunctions.R")
source("04 admmGLASSO.R")
source("07 admmGSLOPE.R")
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
source("04 admmGLASSO.R")
source("07 admmGSLOPE.R")
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
cat("Das")
cat("Starting ADMM gsLOPE procedure...")
source("04 admmGLASSO.R")
source("07 admmGSLOPE.R")
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
source("04 admmGLASSO.R")
source("07 admmGSLOPE.R")
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = T, truncate = T)$precisionMatrix
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = T, truncate = T)$precisionMatrix
source("07 admmGSLOPE.R")
source("10 simpleMeasures.R")
measures <- function(n=200,
d=200,
graph="cluster",
alpha = .1,
penalizeDiagonal = FALSE,
epsilon = 10e-4,
simulationsNumber = 1000,  # Numer of graphs simulated to calculated FDR
verbose = TRUE)
{
if(verbose)
{
cat("Starting FDR simulations\nn = ", n, "\nd = ", d, "\ngraph structure = ", graph,
"\nsimulations number = ", simulationsNumber, "\n")
progressBar <- txtProgressBar(min = 0, max = simulationsNumber, style = 3)
setTxtProgressBar(progressBar, 0)
}
gLASSO <- list(FDR = NULL,
SN = NULL,
SP = NULL)
gSLOPE <- list(FDR = NULL,
SN = NULL,
SP = NULL)
# gLASSO parameters
m     <- d*(d-1)/2
mBanerjee <- d^2
banerjeeLassoLambda <- qt(1-alpha/2/mBanerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/mBanerjee, df = n-2)^2)
# gSLOPE parameters
k = 1:m
BHlambda <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
BHSlopeLambda <- c(rep(BHlambda[1], d), rep(BHlambda, each=2))
for(i in 1:simulationsNumber)
{
graphHUGE <- huge.generator(n, d, graph, verbose = FALSE)
omegaHATgLASSO <- glasso(graphHUGE$sigmahat, rho = banerjeeLassoLambda, thr = epsilon,
penalize.diagonal = penalizeDiagonal)$wi
# omegaHATgLASSO <- glassoADMM(graphHUGE$sigmahat, lambda = banerjeeLassoLambda,
#                              penalizeDiagonal = penalizeDiagonal,
#                              truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
omegaHATgSLOPE <- gslopeADMM(graphHUGE$sigmahat, lambda = BHSlopeLambda,
penalizeDiagonal = penalizeDiagonal,
truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
gLASSO$FDR <- c(gLASSO$FDR, FDP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$FDR <- c(gSLOPE$FDR, FDP(omegaHATgSLOPE, graphHUGE$omega))
gLASSO$SN <- c(gLASSO$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SN <- c(gSLOPE$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gLASSO$SP <- c(gLASSO$SP, SP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SP <- c(gSLOPE$SP, SP(omegaHATgLASSO, graphHUGE$omega))
if(verbose)
setTxtProgressBar(progressBar, i)
}
if(verbose)
close(progressBar)
return(list(gLASSO = lapply(gLASSO, function(x) sum(x)/simulationsNumber),
gSLOPE = lapply(gSLOPE, function(x) sum(x)/simulationsNumber)))
}
measures <- function(n=200,
d=200,
graph="cluster",
alpha = .1,
penalizeDiagonal = FALSE,
epsilon = 10e-4,
simulationsNumber = 10000,  # Numer of graphs simulated to calculated FDR
verbose = TRUE)
{
if(verbose)
{
cat("Starting FDR simulations\nn = ", n, "\nd = ", d, "\ngraph structure = ", graph,
"\nsimulations number = ", simulationsNumber, "\n")
progressBar <- txtProgressBar(min = 0, max = simulationsNumber, style = 3)
setTxtProgressBar(progressBar, 0)
}
gLASSO <- list(FDR = NULL,
SN = NULL,
SP = NULL)
gSLOPE <- list(FDR = NULL,
SN = NULL,
SP = NULL)
# gLASSO parameters
m     <- d*(d-1)/2
mBanerjee <- d^2
banerjeeLassoLambda <- qt(1-alpha/2/mBanerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/mBanerjee, df = n-2)^2)
# gSLOPE parameters
k = 1:m
BHlambda <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
BHSlopeLambda <- c(rep(BHlambda[1], d), rep(BHlambda, each=2))
for(i in 1:simulationsNumber)
{
graphHUGE <- huge.generator(n, d, graph, verbose = FALSE)
omegaHATgLASSO <- glasso(graphHUGE$sigmahat, rho = banerjeeLassoLambda, thr = epsilon,
penalize.diagonal = penalizeDiagonal)$wi
# omegaHATgLASSO <- glassoADMM(graphHUGE$sigmahat, lambda = banerjeeLassoLambda,
#                              penalizeDiagonal = penalizeDiagonal,
#                              truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
omegaHATgSLOPE <- gslopeADMM(graphHUGE$sigmahat, lambda = BHSlopeLambda,
penalizeDiagonal = penalizeDiagonal,
truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
gLASSO$FDR <- c(gLASSO$FDR, FDP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$FDR <- c(gSLOPE$FDR, FDP(omegaHATgSLOPE, graphHUGE$omega))
gLASSO$SN <- c(gLASSO$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SN <- c(gSLOPE$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gLASSO$SP <- c(gLASSO$SP, SP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SP <- c(gSLOPE$SP, SP(omegaHATgLASSO, graphHUGE$omega))
if(verbose)
setTxtProgressBar(progressBar, i)
}
if(verbose)
close(progressBar)
return(list(gLASSO = lapply(gLASSO, function(x) sum(x)/simulationsNumber),
gSLOPE = lapply(gSLOPE, function(x) sum(x)/simulationsNumber)))
}
results <- measures()
isSymmetric(diag(1:100))
isSymmetric(diag(1:100)
>
d
is.matrix(1)
sort(1:20)
sort(20:1)
20:1
sort(20:1)
sort(20:1, partial = 18)
sort(20:1, partial = 2)
sort(-(20:1), partial = 2)
sort(-(unif(20)), partial = 2)
sort(-(runif(20)), partial = 2)
sort((runif(20)), partial = 2)
-sort(-(runif(20)), partial = 2)
-sort(-(runif(20)), partial = 2)[1,2]
-sort(-(runif(20)), partial = 2)[1:2]
prod(-sort(-(runif(20)), partial = 2)[1:2])
graphHUGE <- huge.generator
graphHUGE <- huge.generator()
require(glasso)
require(huge)
graphHUGE <- huge.generator()
graphHUGE$sigmahat
diag(graphHUGE$sigmahat)
diag(graphHUGE$sigma)
graphHUGE <- huge.generator(graph = "random")
diag(graphHUGE$sigmahat)
graphHUGE <- huge.generator(graph = "hub")
diag(graphHUGE$sigmahat)
cov(scale(graphHUGE$data)) == graphHUGE$sigmahat
cov(graphHUGE$data) == graphHUGE$sigmahat
graphHUGE <- huge.generator(n = 15, d = 15, graph = "hub")
cov(graphHUGE$data) == graphHUGE$sigmahat
cov(scale(graphHUGE$data)) == graphHUGE$sigmahat
cov(scale(graphHUGE$data)) - graphHUGE$sigmahat
round(cov(scale(graphHUGE$data)) - graphHUGE$sigmahat)
round(cov(graphHUGE$data) - graphHUGE$sigmahat)
cov(graphHUGE$data) - graphHUGE$sigmahat
round(cov(graphHUGE$data) - graphHUGE$sigmahat, 2)
round(cov(graphHUGE$data) - graphHUGE$sigmahat, 4)
round(cov(graphHUGE$data) - graphHUGE$sigmahat, 3)
prod(-sort(-(runif(20)), partial = 2)[1:2])
graphHUGE$data
cov(graphHUGE$data)
round(cov(graphHUGE$data) - graphHUGE$sigmahat, 3)
cov(scale(graphHUGE$data)
)
cov(scale(graphHUGE$data))
prod(-sort(-(cov(scale(graphHUGE$data))), partial = 2)[1:2])
prod(-sort(-diag(cov(scale(graphHUGE$data))), partial = 2)[1:2])
-diag(cov(scale(graphHUGE$data)))
qt(1)
qt(1, df = 2)
qt(0, df = 2)
qt(1/2, df = 2)
qt(1/4, df = 2)
qt(0.05, df = 2)
qt(0.05, df = 2)^2
qt(0.05/2/2, df = 2)^2
qt(0.05/(2*2), df = 2)^2
verbose
p = 2
2p
matrix
matrix <0
matrix <- 4
matrix
matrix(4)
diag(matrix)
matrix
matrix(4)
matrix(c(1:5)
)
diag(1:5)
diag(diag(1:5))
diag(1:5)
diag(1:5) -> A
length(A)
length(A[lower.tri(A)])
A[lower.tri(A)]
A[lower.tri(A, F)]
A[lower.tri(A, T)]
length(A[lower.tri(A, F)])
length(A[lower.tri(A, T)])
k <- 1:25
alpha = 0.05
k*alpha/(2*k)
k
k*alpha/(2*k)
k*alpha/2/pBH
pBH <- k[25]
q = k*alpha/2/pBH
q
qnorm(1 - q)
fractionSeq <- qnorm(1-alpha*k/2/pBH)
fractionSeq
fractionSeq <- c(rep(fractionSeq[1], pBH), rep(fractionSeq, each=2))
fractionSeq
p<- 10
pBH <- p*(p-1)/2
k <- 1:pBH
fractionSeq <- qnorm(1-alpha*k/2/pBH)
fractionSeq <- c(rep(fractionSeq[1], pBH), rep(fractionSeq, each=2))
fractionSeq
p<- 25
pBH <- p*(p-1)/2
k <- 1:pBH
fractionSeq <- qnorm(1-alpha*k/2/pBH)
fractionSeq <- c(rep(fractionSeq[1], pBH), rep(fractionSeq, each=2))
fractionSeq
fractionSeq <- qnorm(1-alpha*k/2/pBH)
fractionSeq <- c(rep(fractionSeq[1], p), rep(fractionSeq, each=2))
fractionSeq
p<- 25
pBH <- p*(p-1)/2
k <- 1:pBH
p<- 25
fractionSeq <- qnorm(1-alpha*k/2/pBH)
fractionSeq <- c(rep(fractionSeq[1], p), rep(fractionSeq, each=2))
fractionSeq
pBH <- p*(p-1)/2
k <- 1:pBH
p<- 10
pBH <- p*(p-1)/2
k <- 1:pBH
p<- 10
fractionSeq <- qnorm(1-alpha*k/2/pBH)
fractionSeq <- c(rep(fractionSeq[1], p), rep(fractionSeq, each=2))
fractionSeq
p<- 5
pBH <- p*(p-1)/2
k <- 1:pBH
p<- 5
fractionSeq <- qnorm(1-alpha*k/2/pBH)
fractionSeq <- c(rep(fractionSeq[1], p), rep(fractionSeq, each=2))
fractionSeq
source('~/01 Projekty/02 Magisterka/gSLOPE/01 auxilaryFunctions.R')
matrix
matrix <- matrix(rnorm(25), 5,5)
matrix
lambdaParameter(matrix)
lambdaParameter(matrix, method = bonf)
lambdaParameter(matrix, method = "bonf")
lambdaParameter <- function(matrix, n, alpha = 0.05, method = "banerjee", verbose = TRUE)
{
out = switch(method,
banerjee = lambdaBanerjee(matrix, n, alpha, verbose),
bonf = lambdaBonf(matrix, n, alpha, verbose),
banerjeeSlope = lambdaBS(matrix, n, alpha, verbose),
BH = lambdaBH(matrix, n, alpha, verbose))
return(out)
}
lambdaParameter(matrix, method = "bonf")
lambdaParameter(matrix)
lambdaParameter(matrix, method = "BH")
lambdaParameter(matrix, method = "banerjeeSlope")
lambdaBS <- function(matrix, n, alpha = 0.05, verbose = TRUE)
{
p <- ncol(matrix)
if(!isSymmetric(matrix))
{
if(verbose) cat("The input is identified as the data matrix.\n")
n <- nrow(matrix)
matrix <- cov(scale(matrix))
twoLargestProd <- 1
} else
{
if(verbose) cat("The input is identified as the covariance matrix.\n")
twoLargestProd <- prod(-sort(-diag(matrix), partial = 2)[1:2]) # In case data wasn't scaled
}
pBS <- p*(p-1)/2
k <- 1:pBS
fractionSeq <- qt(1-alpha*k/2/pBS, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/pBS, df = n-2)^2)
fractionSeq <- c(rep(fractionSeq[1], p), rep(fractionSeq, each=2))
return(twoLargestProd*fractionSeq)
}
lambdaParameter(matrix, method = "banerjeeSlope")
lambdaParameter(matrix, method = "BH")
lambdaParameter <- function(matrix, n, alpha = 0.05, method = "banerjee", verbose = TRUE)
{
out = switch(method,
banerjee = lambdaBanerjee(matrix, n, alpha, verbose),
bonf = lambdaBonf(matrix, n, alpha, verbose),
BS = lambdaBS(matrix, n, alpha, verbose),
BH = lambdaBH(matrix, n, alpha, verbose))
return(out)
}
lambdaParameter(matrix, method = "BS")
lambdaParameter(cov(scale(matrix)), method = "BS")
lambdaParameter(cov(scale(matrix)), n = 5, method = "BS")
lambdaParameter(cov(scale(matrix)), n = 7, method = "BS")
lambdaParameter(5, n = 5, method = "BS")
source('~/01 Projekty/02 Magisterka/gSLOPE/01 auxilaryFunctions.R')
lambdaParameter(5, n = 5, method = "BS")
source('~/01 Projekty/02 Magisterka/gSLOPE/01 auxilaryFunctions.R')
lambdaParameter(5, n = 5, method = "BS")
source('~/01 Projekty/02 Magisterka/gSLOPE/01 auxilaryFunctions.R')
lambdaParameter(5, n = 5, method = "BS")
source('~/01 Projekty/02 Magisterka/gSLOPE/01 auxilaryFunctions.R')
lambdaParameter(5, n = 5, method = "BS")
source('~/01 Projekty/02 Magisterka/gSLOPE/01 auxilaryFunctions.R')
lambdaParameter(5, n = 5, method = "BS")
is.matrix(1:2)
x<-3
x[1]
source('~/01 Projekty/02 Magisterka/gSLOPE/01 auxilaryFunctions.R')
lambdaParameter(5, 5, method = "BS")
lambdaParameter(5, 5, method = "BH")
lambdaParameter(5, n = 5, method = "BH")
lambdaParameter(5, 5, method = "banerjee")
lambdaParameter(5, 5, method = "bonf")
source('~/01 Projekty/02 Magisterka/gSLOPE/01 auxilaryFunctions.R')
lambdaParameter(5, 5, method = "bonf")
lambdaParameter(5, 5, method = "banerjee")
lambdaParameter(5, n = 5, method = "BH")
lambdaParameter(5, n = 5, method = "BS")
n=200,
p=200,
graph="cluster",
alpha = .1,
penalizeDiagonal = FALSE,
epsilon = 10e-4,
simulationsNumber = 10000,  # Numer of graphs simulated to calculated FDR
verbose = TRUE
n=10
p = 10
alpha = .1
verbose = FALSE
# gLASSO parameters
m     <- p*(p-1)/2
mBanerjee <- p^2
banerjeeLassoLambda <-
qt(1-alpha/2/mBanerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/mBanerjee, df = n-2)^2)
banerjeeLassoLambda
lambdaSelector(p, n, alpha, method = "banerjee", verbose)
# gSLOPE parameters
k = 1:m
BHlambda <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
BHSlopeLambda <- c(rep(BHlambda[1], p), rep(BHlambda, each=2))
BHSlopeLambda
lambdaSelector(p, n, alpha, method = "BH", verbose)
m
lambdaSelector(p, n, alpha, method = "BS", verbose)
BHSlopeLambda
lambdaSelector(p, n, alpha, method = "BS", verbose) == BHSlopeLambda
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R')
results <- FDR()
results <- measures()
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R')
results <- measures()
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R')
results <- measures()
results <- measures(simulationsNumber = 5000)
results
matrix(results)
matrix(results$gLASSO, results$gLASSO)
matrix(as.vector(results$gLASSO))
matrix(as.vector(results))
matrix(as.vector(as.vector(results)))
matrix(results$gLASSO)
matrix(c(results[[1]]))
matrix(c(results[[1]], results[[2]], results[[3]]))
matrix(c(results[[1]], results[[2]], results[[3]]), nrow = 3)
matrix(c(results[[1]], results[[2]], results[[3]]), ncol = 3)
matrix(c(results[[1]], results[[2]], results[[3]]), nrow = 3, colnames = c(2,3,4))
data.frame(c(results[[1]], results[[2]], results[[3]]), nrow = 3
)
data.frame(resluts)
data.frame(results)
data.frame(results, ncol = 3)
data.frame(rbind(results[[1]], results[[2]]))
data.frame(rbind(results[[1]], results[[2]], results[[3]]), row.names = names(results))
data.frame(cbind(results[[1]], results[[2]], results[[3]]), row.names = names(results))
data.frame(cbind(results[[1]], results[[2]], results[[3]]), row.names = names(results[[1]]))
data.frame(rbind(results[[1]], results[[2]], results[[3]]), row.names = names(results))
t(data.frame(rbind(results[[1]], results[[2]], results[[3]]), row.names = names(results)))
data.frame(rbind(results[[1]], results[[2]], results[[3]]), row.names = names(results))
resultsTable <- data.frame(rbind(results[[1]], results[[2]], results[[3]]), row.names = names(results))
colnames(resultsTable) <- c("FDR", "Sensitivity", "Specificity")
resultsTable
View(resultsTable)
