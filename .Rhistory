sum(t(x)[x == 0] != 0)
3/2
3/2 == 1.5
6/4 == 1.5
60/04 == 1.5
60/40 == 1.5
60/4/10 == 1.5
60/4/*,10 == 1.5
60/4/*.10 == 1.5
60/4*.10 == 1.5
T = 1
T = 23
T = 0
max(c(1,2,NA),na.rm = T)
max(c(1,2,NA),na.rm = F)
max(c(1,2,NA),na.rm = TRUE)
qr.Q(qr(replicate(dims[j], rnorm(n, 0, 1))))
rnorm(10, 0, 1)
replicate(dims[1], rnorm(n, 0, 1))
replicate(3, rnorm(n, 0, 1))
replicate(3, rnorm(3, 0, 1))
replicate(10, rnorm(3, 0, 1))
replicate(2, rnorm(100, 0, 1))
qr(replicate(2, rnorm(100, 0, 1)))
qr.Q(qr(replicate(2, rnorm(100, 0, 1))))
qr.Q(qr(replicate(2, rnorm(100, 0, 1)))) == qr(replicate(2, rnorm(100, 0, 1)))$qr
qr.Q(qr(replicate(2, rnorm(100, 0, 1)))) == qr(replicate(2, rnorm(100, 0, 1)))$qr[lower.tri(qr(replicate(2, rnorm(100, 0, 1)))$qr)]
qr.Q(qr(replicate(2, rnorm(100, 0, 1)))) == qr(replicate(2, rnorm(100, 0, 1)))$qr
qr(replicate(2, rnorm(100, 0, 1)))$qr*t(qr(replicate(2, rnorm(100, 0, 1)))$qr)
qr(replicate(2, rnorm(100, 0, 1)))$qr%*%t(qr(replicate(2, rnorm(100, 0, 1)))$qr)
qr(replicate(2, rnorm(100, 0, 1)))$qr*t(qr(replicate(2, rnorm(100, 0, 1)))$qr)
replicate(2, rnorm(100, 0, 1))
wq <- qr.Q(qr(replicate(2, rnorm(100, 0, 1))))
wg*t(wq)
wq*t(wq)
wq%*%t(wq)
wq
wq <- qr.Q(qr(replicate(2, rnorm(100, 0, 1))))
wq
t(wq)
t(wq)*wq
t(wq)$*$wq
t(wq)%*%wq
wq%*%t(wq)
t(wq)%*%wq
matrix(runif(2 * 30, 0.1, 1) *
sign(runif(2 * 30, -1, 1)), nrow = 2)
coef <- matrix(runif(2 * 30, 0.1, 1) *
sign(runif(2 * 30, -1, 1)), nrow = 2)
wq %*% coef
wq * coef
dim(wq)
dim(coef)
scale(matrix(1:25, 5, 5))
mean(scale(matrix(1:25, 5, 5)))
var(scale(matrix(1:25, 5, 5)))
covv(scale(matrix(1:25, 5, 5)))
cov(scale(matrix(1:25, 5, 5)))
norm(scale(matrix(1:25, 5, 5)))
scale(matrix(1:25, 5, 5))
wq * coef
scale(wq %*% coef)
FDPseries <- c()
FDPseries <- NULL
require(glasso)
require(huge)
install.packages("huge")
require(tictoc)
install.packages("tictoc")
require(tictoc)
source('~/.active-rstudio-document', echo=TRUE)
toc()
source('~/.active-rstudio-document', echo=TRUE)
require(glasso)
require(huge)
graphHUGE <- huge.generator(10, 10, "cluster")
graphHUGE$data
graphHUGE$graph.type
graphHUGE
graphHUGE$sigma
graphHUGE$sigmahat
graphHUGE$omega
graphHUGE$theta
require(glasso)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=TRUE)
results <- FDR()
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=TRUE)
results <- FDR()
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=TRUE)
results <- FDR()
results
testit <- function(x = sort(runif(20)), ...)
{
pb <- txtProgressBar(...)
for(i in c(0, x, 1)) {Sys.sleep(0.5); setTxtProgressBar(pb, i)}
Sys.sleep(1)
close(pb)
}
testit()
testit(style = 3)
testit <- function(x = 1:20, ...)
{
pb <- txtProgressBar(...)
for(i in c(0, x, 1)) {Sys.sleep(0.5); setTxtProgressBar(pb, i)}
Sys.sleep(1)
close(pb)
}
testit <- function(x = 1:20, ...)
{
pb <- txtProgressBar(...)
for(i in c(0, x, 1)) {Sys.sleep(0.5); setTxtProgressBar(pb, i)}
Sys.sleep(.1)
close(pb)
}
testit <- function(x = seq(0, 1, 20), ...)
{
pb <- txtProgressBar(...)
for(i in x) {Sys.sleep(0.5); setTxtProgressBar(pb, i)}
Sys.sleep(.1)
close(pb)
}
testit()
testit(runif(10))
seq(0, 1, 20)
seq(from = 0, to = 1, len = 20)
testit <- function(x = seq(from = 0, to = 1, len = 20), ...)
{
pb <- txtProgressBar(...)
for(i in x) {Sys.sleep(0.5); setTxtProgressBar(pb, i)}
Sys.sleep(.1)
close(pb)
}
testit()
testit(runif(10))
testit(style = 3)
testit(title = "Progress", style = 3)
FDR(simulationsNumber = 20)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=TRUE)
FDR(simulationsNumber = 20)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=TRUE)
FDR(simulationsNumber = 10)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=TRUE)
FDR(simulationsNumber = 10)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=TRUE)
FDR(simulationsNumber = 10)
results <- FDR(simulationsNumber = 10)
results
results$FDRgLASSO
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=FALSE)
results <- FDR(simulationsNumber = 10)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=FALSE)
results <- FDR(simulationsNumber = 10)
results
set.seed(10)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=FALSE)
set.seed(10)
results <- FDR(simulationsNumber = 10)
results
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=FALSE)
set.seed(10)
results <- FDR(simulationsNumber = 10)
results
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=FALSE)
results <- FDR(simulationsNumber = 10)
results
pts <- list(x = cars[,1], y = cars[,2])
pts
gLASSO <- list(FDP = NULL,
SN = NULL,
SP = NULL)
gSLOPE <- list(FDP = NULL,
SN = NULL,
SP = NULL)
gLASSO
gSLOPE <- list(FDP = c(10,20),
SN = c(10,20),
SP = c(10,20))
gSLOPE
gSLOPE/2
laplly(gSLOPE,/2)
laplly(gSLOPE,function(x) x/2)
lapply(gSLOPE,function(x) x/2)
lapply(gSLOPE, x/2)
lapply(gSLOPE, 2)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R', echo=TRUE)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R')
measures(simulationsNumber = 10)
gLASSO <- list("FDR" = NULL,
SN = NULL,
SP = NULL)
gLASSO
gLASSO <- list('FDR' = NULL,
SN = NULL,
SP = NULL)
gLASSO
gLASSO <- list(NULL,
SN = NULL,
SP = NULL)
gLASSO
names(gLASSO)
names(gLASSO)[1]
names(gLASSO)[1] <- "FDR"
glasso
gLASSO
names(gLASSO)
source('~/01 Projekty/02 Magisterka/gSLOPE/11 FDR.R')
measures <- function(n=200,
d=200,
graph="cluster",
alpha = .05,
penalizeDiagonal = FALSE,
epsilon = 10e-4,
simulationsNumber = 1000,  # Numer of graphs simulated to calculated FDR
verbose = TRUE)
{
if(verbose)
{
cat("Starting FDR simulations\nn = ", n, "\nd = ", d, "\ngraph structure = ", graph,
"\nsimulations number = ", simulationsNumber, "\n")
progressBar <- txtProgressBar(min = 0, max = simulationsNumber, style = 3)
setTxtProgressBar(progressBar, 0)
}
gLASSO <- list(FDR = NULL,
SN = NULL,
SP = NULL)
gSLOPE <- list(FDR = NULL,
SN = NULL,
SP = NULL)
# gLASSO parameters
m     <- d*(d-1)/2
mBanerjee <- d^2
banerjeeLassoLambda <- qt(1-alpha/2/mBanerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/mBanerjee, df = n-2)^2)
# gSLOPE parameters
k = 1:m
BHlambda <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
BHSlopeLambda <- c(rep(BHlambda[1], d), rep(BHlambda, each=2))
for(i in 1:simulationsNumber)
{
graphHUGE <- huge.generator(n, d, graph, verbose = FALSE)
omegaHATgLASSO <- glasso(graphHUGE$sigmahat, rho = banerjeeLassoLambda, thr = epsilon,
penalize.diagonal = penalizeDiagonal)$wi
# omegaHATgLASSO <- glassoADMM(graphHUGE$sigmahat, lambda = banerjeeLassoLambda,
#                              penalizeDiagonal = penalizeDiagonal,
#                              truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
omegaHATgSLOPE <- gslopeADMM(graphHUGE$sigmahat, lambda = BHSlopeLambda,
penalizeDiagonal = penalizeDiagonal,
truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
gLASSO$FDR <- c(gLASSO$FDR, FDP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$FDR <- c(gSLOPE$FDR, FDP(omegaHATgSLOPE, graphHUGE$omega))
gLASSO$SN <- c(gLASSO$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SN <- c(gSLOPE$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gLASSO$SP <- c(gLASSO$SP, SP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SP <- c(gSLOPE$SP, SP(omegaHATgLASSO, graphHUGE$omega))
if(verbose)
setTxtProgressBar(progressBar, i)
}
if(verbose)
close(progressBar)
return(list(gLASSO = lapply(gLASSO, function(x) sum(x)/simulationsNumber),
gSLOPE = lapply(gSLOPE, function(x) sum(x)/simulationsNumber)))
}
measures(simulationsNumber = 2)
source("07 admmGSLOPE.R")
measures(simulationsNumber = 2)
source("10 simpleMeasures.R")
measures(simulationsNumber = 2)
max(1,2,3,4)
source("02 softThresholding.R")
# C - sample covariance
# mu - Augmented Lagrangian parameter
# lambda - Regularization parameter controlling sparsity
# maxIter - maximum number of iterations
# absoluteEpsilon - used in residual stopping criterium
# truncate - should entries below absoluteEpsilon be equal to zero?
glassoADMM <- function(sampleCovariance,
mu = 1,
lambda = 1,
penalizeDiagonal = TRUE,
maxIter = 1e5,
absoluteEpsilon = 1e-4,
relativeEpsilon = 1e-4,
truncate = TRUE,
verbose = TRUE)
{
if(verbose)
{
cat("Starting ADMM gLASSO procedure...")
progressBar <- txtProgressBar(min = 0, max = 1/absoluteEpsilon, style = 3)
setTxtProgressBar(progressBar, 0)
}
# Checks
if(!is.matrix(lambda) & length(lambda)!=1 & length(lambda)!=nrow(sampleCovariance))
{
stop("Wrong number of elements in lambda")
}
if(length(lambda)==1)
{
if(lambda==0)
{
warning("With lambda=0, there may be convergence problems if the input matrix is not of full rank")
}
lambda <- round(lambda, round(log10( (1/absoluteEpsilon))))
Z <- sampleCovariance*0 # Initialize Lagragian to be nothing (seems to work well)
Y <- Z
X <- diag(nrow = nrow(sampleCovariance), ncol = ncol(sampleCovariance))
for(n in 1:maxIter)
{
# Solve sub-problem to solve X
Ctilde <- Y-Z-sampleCovariance/mu
Ceigen <- eigen(Ctilde)
CeigenVal <- Ceigen$val
CeigenVec <- Ceigen$vec
Fmu <- 1/2*diag(CeigenVal+sqrt(CeigenVal*CeigenVal+4/mu))
X <- CeigenVec%*%Fmu%*%t(CeigenVec)
# Solve sub-problem to solve Y
Yold <- Y
Y <- softThresholding(X+Z, lambda/mu, penalizeDiagonal)
# Update the Lagrangian
Z <- Z + mu*(X-Y)
# Residuals
primalResidual <- norm(X-Y, type = "F")
dualResidual   <- norm(mu*(Y-Yold), type = "F")
# Stopping criteria
primalEpsilon <- absoluteEpsilon # + relativeEpsilon*max(l2norm(X), l2norm(Y))
dualEpsilon   <- absoluteEpsilon # + relativeEpsilon*l2norm(Z)
if(verbose)
setTxtProgressBar(progressBar, min(1/primalResidual, 1/dualResidual))
if(primalResidual < primalEpsilon & dualResidual < dualEpsilon)
break
# if(n %% 10000 == 0)
#     print(paste(n, "iterations done..."), quote = F)
}
if(truncate)
X[X < absoluteEpsilon] <- 0
if(verbose)
close(progressBar)
return(list(sampleCovariance = sampleCovariance,
lambda = lambda,
lagrangianParameter = mu,
diagonalPenalization = penalizeDiagonal,
precisionMatrix = X,
covarianceMatrix = solve(X),
residuals = c(primalResidual, dualResidual),
iterations = n,
truncated = truncate,
epsilon = absoluteEpsilon))
}
data  <- scale(dataSimulator(n = 100, SNR = 1, K = 5, numb.vars = 30, max.dim = 3)$X)
source("01 auxilaryFunctions.R")
source("07 admmGSLOPE.R")
data  <- scale(dataSimulator(n = 100, SNR = 1, K = 5, numb.vars = 30, max.dim = 3)$X)
sampleCovariance <- cov(data)
n     <- nrow(data)
p     <- ncol(data)
m     <- p*(p-1)/2
alpha <- 0.05
m_banerjee <- p^2
lambda <- qt(1-alpha/2/m_banerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/m_banerjee, df = n-2)^2)
k = 1:m
lambdaBis <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
lambdaSeries <- c(rep(lambdaBis[1], p), rep(lambdaBis, each=2))
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = T, truncate = T)$precisionMatrix
set.seed(100)
data  <- scale(dataSimulator(n = 100, SNR = 1, K = 5, numb.vars = 30, max.dim = 3)$X)
sampleCovariance <- cov(data)
n     <- nrow(data)
p     <- ncol(data)
m     <- p*(p-1)/2
alpha <- 0.05
m_banerjee <- p^2
lambda <- qt(1-alpha/2/m_banerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/m_banerjee, df = n-2)^2)
k = 1:m
lambdaBis <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
lambdaSeries <- c(rep(lambdaBis[1], p), rep(lambdaBis, each=2))
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = T, truncate = T)$precisionMatrix
source("01 auxilaryFunctions.R")
source("04 admmGLASSO.R")
source("07 admmGSLOPE.R")
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
source("04 admmGLASSO.R")
source("07 admmGSLOPE.R")
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
cat("Das")
cat("Starting ADMM gsLOPE procedure...")
source("04 admmGLASSO.R")
source("07 admmGSLOPE.R")
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
source("04 admmGLASSO.R")
source("07 admmGSLOPE.R")
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = F, truncate = T)$precisionMatrix
precisionGLASSOADMM <- glassoADMM(sampleCovariance, lambda = lambda, penalizeDiagonal = T, truncate = T)$precisionMatrix
precisionGSLOPEADMM <- gslopeADMM(sampleCovariance, lambda = lambdaSeries, penalizeDiagonal = T, truncate = T)$precisionMatrix
source("07 admmGSLOPE.R")
source("10 simpleMeasures.R")
measures <- function(n=200,
d=200,
graph="cluster",
alpha = .1,
penalizeDiagonal = FALSE,
epsilon = 10e-4,
simulationsNumber = 1000,  # Numer of graphs simulated to calculated FDR
verbose = TRUE)
{
if(verbose)
{
cat("Starting FDR simulations\nn = ", n, "\nd = ", d, "\ngraph structure = ", graph,
"\nsimulations number = ", simulationsNumber, "\n")
progressBar <- txtProgressBar(min = 0, max = simulationsNumber, style = 3)
setTxtProgressBar(progressBar, 0)
}
gLASSO <- list(FDR = NULL,
SN = NULL,
SP = NULL)
gSLOPE <- list(FDR = NULL,
SN = NULL,
SP = NULL)
# gLASSO parameters
m     <- d*(d-1)/2
mBanerjee <- d^2
banerjeeLassoLambda <- qt(1-alpha/2/mBanerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/mBanerjee, df = n-2)^2)
# gSLOPE parameters
k = 1:m
BHlambda <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
BHSlopeLambda <- c(rep(BHlambda[1], d), rep(BHlambda, each=2))
for(i in 1:simulationsNumber)
{
graphHUGE <- huge.generator(n, d, graph, verbose = FALSE)
omegaHATgLASSO <- glasso(graphHUGE$sigmahat, rho = banerjeeLassoLambda, thr = epsilon,
penalize.diagonal = penalizeDiagonal)$wi
# omegaHATgLASSO <- glassoADMM(graphHUGE$sigmahat, lambda = banerjeeLassoLambda,
#                              penalizeDiagonal = penalizeDiagonal,
#                              truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
omegaHATgSLOPE <- gslopeADMM(graphHUGE$sigmahat, lambda = BHSlopeLambda,
penalizeDiagonal = penalizeDiagonal,
truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
gLASSO$FDR <- c(gLASSO$FDR, FDP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$FDR <- c(gSLOPE$FDR, FDP(omegaHATgSLOPE, graphHUGE$omega))
gLASSO$SN <- c(gLASSO$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SN <- c(gSLOPE$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gLASSO$SP <- c(gLASSO$SP, SP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SP <- c(gSLOPE$SP, SP(omegaHATgLASSO, graphHUGE$omega))
if(verbose)
setTxtProgressBar(progressBar, i)
}
if(verbose)
close(progressBar)
return(list(gLASSO = lapply(gLASSO, function(x) sum(x)/simulationsNumber),
gSLOPE = lapply(gSLOPE, function(x) sum(x)/simulationsNumber)))
}
measures <- function(n=200,
d=200,
graph="cluster",
alpha = .1,
penalizeDiagonal = FALSE,
epsilon = 10e-4,
simulationsNumber = 10000,  # Numer of graphs simulated to calculated FDR
verbose = TRUE)
{
if(verbose)
{
cat("Starting FDR simulations\nn = ", n, "\nd = ", d, "\ngraph structure = ", graph,
"\nsimulations number = ", simulationsNumber, "\n")
progressBar <- txtProgressBar(min = 0, max = simulationsNumber, style = 3)
setTxtProgressBar(progressBar, 0)
}
gLASSO <- list(FDR = NULL,
SN = NULL,
SP = NULL)
gSLOPE <- list(FDR = NULL,
SN = NULL,
SP = NULL)
# gLASSO parameters
m     <- d*(d-1)/2
mBanerjee <- d^2
banerjeeLassoLambda <- qt(1-alpha/2/mBanerjee, df = n-2)/sqrt(n-2+qt(1-alpha/2/mBanerjee, df = n-2)^2)
# gSLOPE parameters
k = 1:m
BHlambda <- qt(1-alpha*k/2/m, df = n-2)/sqrt(n-2+qt(1-alpha*k/2/m, df = n-2)^2)
BHSlopeLambda <- c(rep(BHlambda[1], d), rep(BHlambda, each=2))
for(i in 1:simulationsNumber)
{
graphHUGE <- huge.generator(n, d, graph, verbose = FALSE)
omegaHATgLASSO <- glasso(graphHUGE$sigmahat, rho = banerjeeLassoLambda, thr = epsilon,
penalize.diagonal = penalizeDiagonal)$wi
# omegaHATgLASSO <- glassoADMM(graphHUGE$sigmahat, lambda = banerjeeLassoLambda,
#                              penalizeDiagonal = penalizeDiagonal,
#                              truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
omegaHATgSLOPE <- gslopeADMM(graphHUGE$sigmahat, lambda = BHSlopeLambda,
penalizeDiagonal = penalizeDiagonal,
truncate = TRUE, absoluteEpsilon = epsilon, verbose = FALSE)$precisionMatrix
gLASSO$FDR <- c(gLASSO$FDR, FDP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$FDR <- c(gSLOPE$FDR, FDP(omegaHATgSLOPE, graphHUGE$omega))
gLASSO$SN <- c(gLASSO$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SN <- c(gSLOPE$SN, SN(omegaHATgLASSO, graphHUGE$omega))
gLASSO$SP <- c(gLASSO$SP, SP(omegaHATgLASSO, graphHUGE$omega))
gSLOPE$SP <- c(gSLOPE$SP, SP(omegaHATgLASSO, graphHUGE$omega))
if(verbose)
setTxtProgressBar(progressBar, i)
}
if(verbose)
close(progressBar)
return(list(gLASSO = lapply(gLASSO, function(x) sum(x)/simulationsNumber),
gSLOPE = lapply(gSLOPE, function(x) sum(x)/simulationsNumber)))
}
results <- measures()
